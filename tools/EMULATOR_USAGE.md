## 1. 这脚本是干啥的？

它把电脑上的某个串口（比如 COM9）当成“RFID 读卡器”的对端，**模拟一张 M1(S50) 卡**：

* Qt 发 **寻卡 / 防冲突 / 选卡 / 认证 / 读块 / 写块**命令过来
* 脚本按协议回包
* 还能用按钮控制“放卡/收卡”，并显示所有收发包

默认卡里：

* **块1**：`HELLO_RFID_BLOCK1`（16字节）
* **块2**：`DEMO_DATA_BLOCK2!`（16字节）

---

## 2. 运行前准备（一次搞定）

1. 确保 Python ≥ 3.9
2. 安装串口库：

```bash
pip install pyserial
```

3. 确保你已经用虚拟串口软件（如 com0com、VSPE 等）建立了一对串口，比如：

* Qt 连接 **COM8**
* 这个脚本连接 **COM9**
  （两端必须是同一对虚拟串口）

---

## 3. 怎么启动

在脚本所在目录运行：

```bash
python rfid_14443_emulator_gui_with_clearcard.py
```

会弹出一个窗口：**RFID 14443 虚拟串口模拟器（GUI版）**

---

## 4. 界面每个输入框/选项什么意思？

### 串口设置

* **Port**：脚本要打开的串口号（例如 COM9）
* **Baud**：波特率（默认 115200，要和 Qt 那边一致）
* **UID(hex 8位)**：4字节卡号，例如 `B7D2FF79`
* **KeyA(hex 12位)**：6字节 KeyA，例如 `FFFFFFFFFFFF`

> 注意：UID 必须 8 个 hex 字符；KeyA 必须 12 个 hex 字符，否则会弹“参数错误”。

### 速度/行为

* **回包延迟(ms)**：每次回包前额外等一下（让收发慢一点，更像真硬件）
* **抖动(ms)**：在延迟基础上再加一点不固定的“随机抖动”
* **收卡后沉默（不回包）**：勾上后，如果你点了“收卡”，Qt 发啥都**不回包**（模拟“没有卡/没有响应”）
* **日志显示原始帧HEX**：勾上后日志更详细，会显示 raw 帧 hex

---

## 5. 4 个按钮怎么用（最常用流程）

### ✅ 标准测试流程（推荐照做）

1. 点 **连接串口**

   * 成功后日志会显示：已连接、UID、KeyA
2. 点 **模拟放卡**

   * 这一步很重要！不放卡=默认收卡状态
3. 回到 Qt 软件里开始操作：寻卡/读写/认证等
4. 看脚本日志窗口：会看到 `[RX]`（收到 Qt 的命令）和 `[TX]`（脚本回包）

### 按钮功能说明

* **连接串口**：打开 Port 对应串口，并启动收发线程
* **断开串口**：关闭串口并停止线程
* **模拟放卡**：进入“有卡”状态，开始正常回包（SEARCH/ANTICOLL/SELECT/AUTH/READ/WRITE）
* **收卡**：进入“无卡”状态

  * 若勾了“收卡后沉默”，就完全不回包
  * 若没勾，会回一个 status=0x01 的错误包
* **清空日志**：只清屏，不影响卡数据
* **清空卡信息**（调试用）：把 **块1、块2** 都变成 **16字节全0**

  * 等价于：块1=00…00，块2=00…00
  * 并且会清空认证缓存（避免你之前认证过导致判断混乱）

---

## 6. 你想测“块1/块2是否清零”，怎么验证？

推荐步骤：

1. **模拟放卡**
2. Qt 里：认证块1 → 读块1（应看到 16个 `00`）
3. Qt 里：认证块2 → 读块2（应看到 16个 `00`）
4. 如果 Qt 读不到，先看脚本日志里有没有 `[RX] cmd=0x4A`（AUTH）和 `[RX] cmd=0x4B`（READ）

