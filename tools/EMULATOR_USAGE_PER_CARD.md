# RFID 14443 虚拟串口模拟器（多卡 + 弱链路版）使用说明

对应脚本：`rfid_14443_emulator_gui_multicard_impair.py`

> 本说明面向你的 Qt 上位机（通过虚拟串口/真实串口发 14443 模块命令）。
> 协议封包格式、转义规则、校验规则、命令字含义，均按 `ISO_IEC14443.docx` 中的“数据通讯协议”描述实现：帧头 `0x02`，帧尾 `0x03`，内容区出现 `0x02/0x03/0x10` 需在前面插入 `0x10`；校验为从“模块地址”到“数据域最后一字节”的逐字节累加取最后 1 字节。  

---

## 1. 这脚本是干啥的？

它把电脑上的某个串口（如 COM9 或 `/dev/ttyS*`）当成“RFID 14443 读卡模块”的对端，模拟：

- 寻卡（0x46）
- 防冲突（0x47）
- 选卡（0x48）
- 密钥验证 KeyA（0x4A，mode=0x60）
- 读块（0x4B）
- 写块（0x4C）

并新增两类“更像真机”的能力：

1) **多卡**：一次“放卡”可同时存在多张卡（不同 UID / 不同 KeyA / 各自的数据块）。  
2) **弱链路/异常通信**：模拟 **回包延迟**、**抖动**、**丢包**、**乱序回包**（可选重复包），用来压测 Qt 解析/状态机的健壮性。

---

## 2. 运行前准备（一次搞定）

1. Python ≥ 3.9  
2. 安装 pyserial：

```bash
pip install pyserial
```

3. 用虚拟串口软件（如 com0com、VSPE 等）建一对串口，例如：

- Qt 连接：COM8
- 本脚本连接：COM9

（两端必须是同一对虚拟串口）

---

## 3. 怎么启动

在脚本所在目录运行：

```bash
python rfid_14443_emulator_gui_multicard_impair.py
```

会弹出窗口：**RFID 14443 虚拟串口模拟器（GUI版，支持多卡/弱链路）**

---

## 4. 最常用操作流程（照抄就能跑）

### ✅ 标准流程（单卡/多卡都一样）

1. 点 **连接串口**（脚本打开 COM9）
2. 点 **模拟放卡**（开始响应 Qt 发来的命令）
3. 回到 Qt：执行寻卡/读写/认证等操作
4. 看脚本日志：会显示 `[RX]`（收到命令）和 `[TX]`（发送回包）

### “收卡”会发生什么？

- 进入“无卡”状态：认证缓存 + SELECT 锁定都会被清空  
- 如果勾选 **收卡后沉默（不回包）**：Qt 发啥都没回应（更像“真没卡”）
- 不勾选则会回 `status=0x01` 的错误包（便于你调试）

---

## 5. 多卡功能怎么用？

### 5.1 卡列表/启用开关

- **卡列表**里每一行是一张卡：`UID` + `KeyA`
- `[ON]` 表示当前这张卡“在场且可被读写器识别”
- 选中某一行后点 **启用/禁用**，可快速切换某张卡是否参与防冲突/选卡

> 注意：只有“放卡”且至少有 1 张 `[ON]` 卡时，SEARCH/ANTICOLL 才会正常返回。

### 5.2 ANTICOLL 返回哪张卡？

在 **ANTICOLL返回** 下拉框选择：

- `round_robin`：轮询返回（多次 0x47 会轮流报不同 UID）
- `random`：随机返回
- `fixed`：固定返回某一张（由 `fixed索引` 指定）

> 这能模拟：多卡场景下你 Qt 是否能正确处理“每次防冲突返回不一样”的情况。

### 5.3 SELECT 锁定机制（关键！）

- 当 Qt 发送 `0x48 SELECT` 成功后，脚本会 **锁定 selected_uid**
- 后续 `AUTH/READ/WRITE` 都只对 **这张已选中的卡** 生效
- 你可以点 **清除SELECT锁定**，强制回到“未选卡”状态（更容易测试边界）

---

## 6. 弱链路/异常通信怎么用？

这部分用来模拟“真机常见毛病”——尤其是 Qt 用轮询读串口时，最容易在这里暴露 bug。

> 默认这些异常只作用于 **TX 回包（脚本->Qt）**；另外也提供 RX 丢包（忽略收到的命令）。

### 6.1 基础延迟 & 抖动（更像硬件响应时间）

- **基础延迟(ms)**：每个回包至少延迟这么久才发
- **抖动(ms)**：每个回包再额外随机加 0~抖动 的延迟

示例（比较温和）：
- 基础延迟=80，抖动=50

### 6.2 丢包（Packet Loss）

- **丢包率TX(0-1)**：例如 0.1 表示约 10% 的回包直接不发
- **收包丢包RX(0-1)**：例如 0.05 表示约 5% 的命令帧被“脚本假装没收到”

建议压测值：
- TX 丢包 0.05~0.2
- RX 丢包 0.0~0.1（太高会像“完全坏掉”）

### 6.3 乱序回包（Out-of-order）

- **乱序概率TX(0-1)**：当短时间内连续产生多个回包时，有概率与“上一包”交换顺序  
  （效果：你会看到后一个命令的回包先到，前一个回包后到）

推荐测试值：
- 0.1~0.4

### 6.4 复制回包（Duplicate）

- **复制概率TX(0-1)**：某些回包会被额外重复发送一次  
  （效果：Qt 可能收到“同一条回包”两次）

推荐测试值：
- 0.02~0.1

---

## 7. 常见测试用例（建议写进报告的“系统测试”）

1) **多卡轮询 + SELECT 锁定正确性**  
- 放卡 → 启用2张卡 → ANTICOLL=round_robin  
- Qt 连续寻卡，观察 UID 是否轮换  
- 然后对其中一张 SELECT 后读写块1/2，确认只影响被选中的那张

2) **丢包情况下 Qt 是否会卡死**  
- TX 丢包率 0.1  
- Qt 是否会出现“等待回包永远不返回”的死等？是否有超时重试？

3) **乱序回包下的状态机健壮性**  
- 乱序概率 0.3  
- 观察 Qt 是否会把“回包对应错命令”（典型：把 AUTH 的回包当成 READ 的回包）

4) **重复包下的幂等性**  
- 复制概率 0.05  
- Qt 是否会把同一个回包处理两次导致余额/状态重复变化？

---

## 8. 你可能会遇到的坑

- **Qt 端串口波特率要一致**：脚本默认 115200；实验箱真实模块文档常写 19200，但你当前虚拟串口测试多数用 115200（以 Qt 设置为准）。
- **多卡时务必先 SELECT**：没 SELECT 就 AUTH/READ/WRITE，脚本会回 `status=0x01`（相当于“未选卡/流程错误”）。
- **丢包/乱序很容易把 Qt 的“单线程同步逻辑”弄崩**：建议 Qt 侧每条命令都加超时与“按 cmd 匹配回包”的校验。

---

## 9. 文件清单

- 脚本：`rfid_14443_emulator_gui_multicard_impair.py`
- 协议说明：`ISO_IEC14443.docx`


## 单卡放卡/收卡（新增）

在“卡列表”右侧新增：**放卡(选中)**、**收卡(选中)** 按钮。

- 选中某张卡后点击 **放卡(选中)**：只让这一张卡进入天线区（在场）。
- 点击 **收卡(选中)**：只移走这一张卡。
- 卡列表每一行会显示 `[P]`（在场）或 `[-]`（不在场），并用 `*` 标出当前被 SELECT 的卡。

同时保留顶部的 **模拟放卡/收卡**，它们是“全部放卡/全部收卡”的快捷键。
